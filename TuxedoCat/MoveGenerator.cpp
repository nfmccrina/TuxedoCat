/*
* The MIT License (MIT)
*
* Copyright (c) 2016 Nathan McCrina
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to
* deal in the Software without restriction, including without limitation the
* rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
* sell copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
* IN THE SOFTWARE.
*/

#include "TuxedoCat.h"

using namespace TuxedoCat;
using namespace TuxedoCat::Position;
using namespace TuxedoCat::Utility;

static std::vector<Move> moveList;

static uint64_t FileMask[64] = {
	0x0101010101010101ULL, 0x0202020202020202ULL, 0x0404040404040404ULL, 0x0808080808080808ULL,
	0x1010101010101010ULL, 0x2020202020202020ULL, 0x4040404040404040ULL, 0x8080808080808080ULL,
	0x0101010101010101ULL, 0x0202020202020202ULL, 0x0404040404040404ULL, 0x0808080808080808ULL,
	0x1010101010101010ULL, 0x2020202020202020ULL, 0x4040404040404040ULL, 0x8080808080808080ULL,
	0x0101010101010101ULL, 0x0202020202020202ULL, 0x0404040404040404ULL, 0x0808080808080808ULL,
	0x1010101010101010ULL, 0x2020202020202020ULL, 0x4040404040404040ULL, 0x8080808080808080ULL,
	0x0101010101010101ULL, 0x0202020202020202ULL, 0x0404040404040404ULL, 0x0808080808080808ULL,
	0x1010101010101010ULL, 0x2020202020202020ULL, 0x4040404040404040ULL, 0x8080808080808080ULL,
	0x0101010101010101ULL, 0x0202020202020202ULL, 0x0404040404040404ULL, 0x0808080808080808ULL,
	0x1010101010101010ULL, 0x2020202020202020ULL, 0x4040404040404040ULL, 0x8080808080808080ULL,
	0x0101010101010101ULL, 0x0202020202020202ULL, 0x0404040404040404ULL, 0x0808080808080808ULL,
	0x1010101010101010ULL, 0x2020202020202020ULL, 0x4040404040404040ULL, 0x8080808080808080ULL,
	0x0101010101010101ULL, 0x0202020202020202ULL, 0x0404040404040404ULL, 0x0808080808080808ULL,
	0x1010101010101010ULL, 0x2020202020202020ULL, 0x4040404040404040ULL, 0x8080808080808080ULL,
	0x0101010101010101ULL, 0x0202020202020202ULL, 0x0404040404040404ULL, 0x0808080808080808ULL,
	0x1010101010101010ULL, 0x2020202020202020ULL, 0x4040404040404040ULL, 0x8080808080808080ULL

};

static uint64_t RankMask[64] = {
	0x00000000000000FFULL, 0x00000000000000FFULL, 0x00000000000000FFULL, 0x00000000000000FFULL,
	0x00000000000000FFULL, 0x00000000000000FFULL, 0x00000000000000FFULL, 0x00000000000000FFULL,
	0x000000000000FF00ULL, 0x000000000000FF00ULL, 0x000000000000FF00ULL, 0x000000000000FF00ULL,
	0x000000000000FF00ULL, 0x000000000000FF00ULL, 0x000000000000FF00ULL, 0x000000000000FF00ULL,
	0x0000000000FF0000ULL, 0x0000000000FF0000ULL, 0x0000000000FF0000ULL, 0x0000000000FF0000ULL,
	0x0000000000FF0000ULL, 0x0000000000FF0000ULL, 0x0000000000FF0000ULL, 0x0000000000FF0000ULL,
	0x00000000FF000000ULL, 0x00000000FF000000ULL, 0x00000000FF000000ULL, 0x00000000FF000000ULL,
	0x00000000FF000000ULL, 0x00000000FF000000ULL, 0x00000000FF000000ULL, 0x00000000FF000000ULL,
	0x000000FF00000000ULL, 0x000000FF00000000ULL, 0x000000FF00000000ULL, 0x000000FF00000000ULL,
	0x000000FF00000000ULL, 0x000000FF00000000ULL, 0x000000FF00000000ULL, 0x000000FF00000000ULL,
	0x0000FF0000000000ULL, 0x0000FF0000000000ULL, 0x0000FF0000000000ULL, 0x0000FF0000000000ULL,
	0x0000FF0000000000ULL, 0x0000FF0000000000ULL, 0x0000FF0000000000ULL, 0x0000FF0000000000ULL,
	0x00FF000000000000ULL, 0x00FF000000000000ULL, 0x00FF000000000000ULL, 0x00FF000000000000ULL,
	0x00FF000000000000ULL, 0x00FF000000000000ULL, 0x00FF000000000000ULL, 0x00FF000000000000ULL,
	0xFF00000000000000ULL, 0xFF00000000000000ULL, 0xFF00000000000000ULL, 0xFF00000000000000ULL,
	0xFF00000000000000ULL, 0xFF00000000000000ULL, 0xFF00000000000000ULL, 0xFF00000000000000ULL

};

static uint64_t SWNEMask[64] = {
	0x8040201008040201ULL, 0x0080402010080402ULL, 0x0000804020100804ULL, 0x0000008040201008ULL,
	0x0000000080402010ULL, 0x0000000000804020ULL, 0x0000000000008040ULL, 0x0000000000000080ULL,
	0x4020100804020100ULL, 0x8040201008040201ULL, 0x0080402010080402ULL, 0x0000804020100804ULL,
	0x0000008040201008ULL, 0x0000000080402010ULL, 0x0000000000804020ULL, 0x0000000000008040ULL,
	0x2010080402010000ULL, 0x4020100804020100ULL, 0x8040201008040201ULL, 0x0080402010080402ULL,
	0x0000804020100804ULL, 0x0000008040201008ULL, 0x0000000080402010ULL, 0x0000000000804020ULL,
	0x1008040201000000ULL, 0x2010080402010000ULL, 0x4020100804020100ULL, 0x8040201008040201ULL,
	0x0080402010080402ULL, 0x0000804020100804ULL, 0x0000008040201008ULL, 0x0000000080402010ULL,
	0x0804020100000000ULL, 0x1008040201000000ULL, 0x2010080402010000ULL, 0x4020100804020100ULL,
	0x8040201008040201ULL, 0x0080402010080402ULL, 0x0000804020100804ULL, 0x0000008040201008ULL,
	0x0402010000000000ULL, 0x0804020100000000ULL, 0x1008040201000000ULL, 0x2010080402010000ULL,
	0x4020100804020100ULL, 0x8040201008040201ULL, 0x0080402010080402ULL, 0x0000804020100804ULL,
	0x0201000000000000ULL, 0x0402010000000000ULL, 0x0804020100000000ULL, 0x1008040201000000ULL,
	0x2010080402010000ULL, 0x4020100804020100ULL, 0x8040201008040201ULL, 0x0080402010080402ULL,
	0x0100000000000000ULL, 0x0201000000000000ULL, 0x0402010000000000ULL, 0x0804020100000000ULL,
	0x1008040201000000ULL, 0x2010080402010000ULL, 0x4020100804020100ULL, 0x8040201008040201ULL

};

static uint64_t NWSEMask[64] = {
	0x0000000000000001ULL, 0x0000000000000102ULL, 0x0000000000010204ULL, 0x0000000001020408ULL,
	0x0000000102040810ULL, 0x0000010204081020ULL, 0x0001020408102040ULL, 0x0102040810204080ULL,
	0x0000000000000102ULL, 0x0000000000010204ULL, 0x0000000001020408ULL, 0x0000000102040810ULL,
	0x0000010204081020ULL, 0x0001020408102040ULL, 0x0102040810204080ULL, 0x0204081020408000ULL,
	0x0000000000010204ULL, 0x0000000001020408ULL, 0x0000000102040810ULL, 0x0000010204081020ULL,
	0x0001020408102040ULL, 0x0102040810204080ULL, 0x0204081020408000ULL, 0x0408102040800000ULL,
	0x0000000001020408ULL, 0x0000000102040810ULL, 0x0000010204081020ULL, 0x0001020408102040ULL,
	0x0102040810204080ULL, 0x0204081020408000ULL, 0x0408102040800000ULL, 0x0810204080000000ULL,
	0x0000000102040810ULL, 0x0000010204081020ULL, 0x0001020408102040ULL, 0x0102040810204080ULL,
	0x0204081020408000ULL, 0x0408102040800000ULL, 0x0810204080000000ULL, 0x1020408000000000ULL,
	0x0000010204081020ULL, 0x0001020408102040ULL, 0x0102040810204080ULL, 0x0204081020408000ULL,
	0x0408102040800000ULL, 0x0810204080000000ULL, 0x1020408000000000ULL, 0x2040800000000000ULL,
	0x0001020408102040ULL, 0x0102040810204080ULL, 0x0204081020408000ULL, 0x0408102040800000ULL,
	0x0810204080000000ULL, 0x1020408000000000ULL, 0x2040800000000000ULL, 0x4080000000000000ULL,
	0x0102040810204080ULL, 0x0204081020408000ULL, 0x0408102040800000ULL, 0x0810204080000000ULL,
	0x1020408000000000ULL, 0x2040800000000000ULL, 0x4080000000000000ULL, 0x8000000000000000ULL

};

uint64_t KnightAttacks[64] = {
	0x0000000000020400ULL, 0x0000000000050800ULL, 0x00000000000A1100ULL, 0x0000000000142200ULL,
	0x0000000000284400ULL, 0x0000000000508800ULL, 0x0000000000A01000ULL, 0x0000000000402000ULL,
	0x0000000002040004ULL, 0x0000000005080008ULL, 0x000000000A110011ULL, 0x0000000014220022ULL,
	0x0000000028440044ULL, 0x0000000050880088ULL, 0x00000000A0100010ULL, 0x0000000040200020ULL,
	0x0000000204000402ULL, 0x0000000508000805ULL, 0x0000000A1100110AULL, 0x0000001422002214ULL,
	0x0000002844004428ULL, 0x0000005088008850ULL, 0x000000A0100010A0ULL, 0x0000004020002040ULL,
	0x0000020400040200ULL, 0x0000050800080500ULL, 0x00000A1100110A00ULL, 0x0000142200221400ULL,
	0x0000284400442800ULL, 0x0000508800885000ULL, 0x0000A0100010A000ULL, 0x0000402000204000ULL,
	0x0002040004020000ULL, 0x0005080008050000ULL, 0x000A1100110A0000ULL, 0x0014220022140000ULL,
	0x0028440044280000ULL, 0x0050880088500000ULL, 0x00A0100010A00000ULL, 0x0040200020400000ULL,
	0x0204000402000000ULL, 0x0508000805000000ULL, 0x0A1100110A000000ULL, 0x1422002214000000ULL,
	0x2844004428000000ULL, 0x5088008850000000ULL, 0xA0100010A0000000ULL, 0x4020002040000000ULL,
	0x0400040200000000ULL, 0x0800080500000000ULL, 0x1100110A00000000ULL, 0x2200221400000000ULL,
	0x4400442800000000ULL, 0x8800885000000000ULL, 0x100010A000000000ULL, 0x2000204000000000ULL,
	0x0004020000000000ULL, 0x0008050000000000ULL, 0x00110A0000000000ULL, 0x0022140000000000ULL,
	0x0044280000000000ULL, 0x0088500000000000ULL, 0x0010A00000000000ULL, 0x0020400000000000ULL

};

uint64_t KingAttacks[64] = {
	0x0000000000000302ULL, 0x0000000000000705ULL, 0x0000000000000E0AULL, 0x0000000000001C14ULL,
	0x0000000000003828ULL, 0x0000000000007050ULL, 0x000000000000E0A0ULL, 0x000000000000C040ULL,
	0x0000000000030203ULL, 0x0000000000070507ULL, 0x00000000000E0A0EULL, 0x00000000001C141CULL,
	0x0000000000382838ULL, 0x0000000000705070ULL, 0x0000000000E0A0E0ULL, 0x0000000000C040C0ULL,
	0x0000000003020300ULL, 0x0000000007050700ULL, 0x000000000E0A0E00ULL, 0x000000001C141C00ULL,
	0x0000000038283800ULL, 0x0000000070507000ULL, 0x00000000E0A0E000ULL, 0x00000000C040C000ULL,
	0x0000000302030000ULL, 0x0000000705070000ULL, 0x0000000E0A0E0000ULL, 0x0000001C141C0000ULL,
	0x0000003828380000ULL, 0x0000007050700000ULL, 0x000000E0A0E00000ULL, 0x000000C040C00000ULL,
	0x0000030203000000ULL, 0x0000070507000000ULL, 0x00000E0A0E000000ULL, 0x00001C141C000000ULL,
	0x0000382838000000ULL, 0x0000705070000000ULL, 0x0000E0A0E0000000ULL, 0x0000C040C0000000ULL,
	0x0003020300000000ULL, 0x0007050700000000ULL, 0x000E0A0E00000000ULL, 0x001C141C00000000ULL,
	0x0038283800000000ULL, 0x0070507000000000ULL, 0x00E0A0E000000000ULL, 0x00C040C000000000ULL,
	0x0302030000000000ULL, 0x0705070000000000ULL, 0x0E0A0E0000000000ULL, 0x1C141C0000000000ULL,
	0x3828380000000000ULL, 0x7050700000000000ULL, 0xE0A0E00000000000ULL, 0xC040C00000000000ULL,
	0x0203000000000000ULL, 0x0507000000000000ULL, 0x0A0E000000000000ULL, 0x141C000000000000ULL,
	0x2838000000000000ULL, 0x5070000000000000ULL, 0xA0E0000000000000ULL, 0x40C0000000000000ULL

};

uint64_t RayAttacksN[64] = {
	0x0101010101010100ULL, 0x0202020202020200ULL, 0x0404040404040400ULL, 0x0808080808080800ULL,
	0x1010101010101000ULL, 0x2020202020202000ULL, 0x4040404040404000ULL, 0x8080808080808000ULL,
	0x0101010101010000ULL, 0x0202020202020000ULL, 0x0404040404040000ULL, 0x0808080808080000ULL,
	0x1010101010100000ULL, 0x2020202020200000ULL, 0x4040404040400000ULL, 0x8080808080800000ULL,
	0x0101010101000000ULL, 0x0202020202000000ULL, 0x0404040404000000ULL, 0x0808080808000000ULL,
	0x1010101010000000ULL, 0x2020202020000000ULL, 0x4040404040000000ULL, 0x8080808080000000ULL,
	0x0101010100000000ULL, 0x0202020200000000ULL, 0x0404040400000000ULL, 0x0808080800000000ULL,
	0x1010101000000000ULL, 0x2020202000000000ULL, 0x4040404000000000ULL, 0x8080808000000000ULL,
	0x0101010000000000ULL, 0x0202020000000000ULL, 0x0404040000000000ULL, 0x0808080000000000ULL,
	0x1010100000000000ULL, 0x2020200000000000ULL, 0x4040400000000000ULL, 0x8080800000000000ULL,
	0x0101000000000000ULL, 0x0202000000000000ULL, 0x0404000000000000ULL, 0x0808000000000000ULL,
	0x1010000000000000ULL, 0x2020000000000000ULL, 0x4040000000000000ULL, 0x8080000000000000ULL,
	0x0100000000000000ULL, 0x0200000000000000ULL, 0x0400000000000000ULL, 0x0800000000000000ULL,
	0x1000000000000000ULL, 0x2000000000000000ULL, 0x4000000000000000ULL, 0x8000000000000000ULL,
	0x0000000000000000ULL, 0x0000000000000000ULL, 0x0000000000000000ULL, 0x0000000000000000ULL,
	0x0000000000000000ULL, 0x0000000000000000ULL, 0x0000000000000000ULL, 0x0000000000000000ULL

};

uint64_t RayAttacksS[64] = {
	0x0000000000000000ULL, 0x0000000000000000ULL, 0x0000000000000000ULL, 0x0000000000000000ULL,
	0x0000000000000000ULL, 0x0000000000000000ULL, 0x0000000000000000ULL, 0x0000000000000000ULL,
	0x0000000000000001ULL, 0x0000000000000002ULL, 0x0000000000000004ULL, 0x0000000000000008ULL,
	0x0000000000000010ULL, 0x0000000000000020ULL, 0x0000000000000040ULL, 0x0000000000000080ULL,
	0x0000000000000101ULL, 0x0000000000000202ULL, 0x0000000000000404ULL, 0x0000000000000808ULL,
	0x0000000000001010ULL, 0x0000000000002020ULL, 0x0000000000004040ULL, 0x0000000000008080ULL,
	0x0000000000010101ULL, 0x0000000000020202ULL, 0x0000000000040404ULL, 0x0000000000080808ULL,
	0x0000000000101010ULL, 0x0000000000202020ULL, 0x0000000000404040ULL, 0x0000000000808080ULL,
	0x0000000001010101ULL, 0x0000000002020202ULL, 0x0000000004040404ULL, 0x0000000008080808ULL,
	0x0000000010101010ULL, 0x0000000020202020ULL, 0x0000000040404040ULL, 0x0000000080808080ULL,
	0x0000000101010101ULL, 0x0000000202020202ULL, 0x0000000404040404ULL, 0x0000000808080808ULL,
	0x0000001010101010ULL, 0x0000002020202020ULL, 0x0000004040404040ULL, 0x0000008080808080ULL,
	0x0000010101010101ULL, 0x0000020202020202ULL, 0x0000040404040404ULL, 0x0000080808080808ULL,
	0x0000101010101010ULL, 0x0000202020202020ULL, 0x0000404040404040ULL, 0x0000808080808080ULL,
	0x0001010101010101ULL, 0x0002020202020202ULL, 0x0004040404040404ULL, 0x0008080808080808ULL,
	0x0010101010101010ULL, 0x0020202020202020ULL, 0x0040404040404040ULL, 0x0080808080808080ULL

};

uint64_t RayAttacksE[64] = {
	0x00000000000000FEULL, 0x00000000000000FCULL, 0x00000000000000F8ULL, 0x00000000000000F0ULL,
	0x00000000000000E0ULL, 0x00000000000000C0ULL, 0x0000000000000080ULL, 0x0000000000000000ULL,
	0x000000000000FE00ULL, 0x000000000000FC00ULL, 0x000000000000F800ULL, 0x000000000000F000ULL,
	0x000000000000E000ULL, 0x000000000000C000ULL, 0x0000000000008000ULL, 0x0000000000000000ULL,
	0x0000000000FE0000ULL, 0x0000000000FC0000ULL, 0x0000000000F80000ULL, 0x0000000000F00000ULL,
	0x0000000000E00000ULL, 0x0000000000C00000ULL, 0x0000000000800000ULL, 0x0000000000000000ULL,
	0x00000000FE000000ULL, 0x00000000FC000000ULL, 0x00000000F8000000ULL, 0x00000000F0000000ULL,
	0x00000000E0000000ULL, 0x00000000C0000000ULL, 0x0000000080000000ULL, 0x0000000000000000ULL,
	0x000000FE00000000ULL, 0x000000FC00000000ULL, 0x000000F800000000ULL, 0x000000F000000000ULL,
	0x000000E000000000ULL, 0x000000C000000000ULL, 0x0000008000000000ULL, 0x0000000000000000ULL,
	0x0000FE0000000000ULL, 0x0000FC0000000000ULL, 0x0000F80000000000ULL, 0x0000F00000000000ULL,
	0x0000E00000000000ULL, 0x0000C00000000000ULL, 0x0000800000000000ULL, 0x0000000000000000ULL,
	0x00FE000000000000ULL, 0x00FC000000000000ULL, 0x00F8000000000000ULL, 0x00F0000000000000ULL,
	0x00E0000000000000ULL, 0x00C0000000000000ULL, 0x0080000000000000ULL, 0x0000000000000000ULL,
	0xFE00000000000000ULL, 0xFC00000000000000ULL, 0xF800000000000000ULL, 0xF000000000000000ULL,
	0xE000000000000000ULL, 0xC000000000000000ULL, 0x8000000000000000ULL, 0x0000000000000000ULL

};

uint64_t RayAttacksW[64] = {
	0x0000000000000000ULL, 0x0000000000000001ULL, 0x0000000000000003ULL, 0x0000000000000007ULL,
	0x000000000000000FULL, 0x000000000000001FULL, 0x000000000000003FULL, 0x000000000000007FULL,
	0x0000000000000000ULL, 0x0000000000000100ULL, 0x0000000000000300ULL, 0x0000000000000700ULL,
	0x0000000000000F00ULL, 0x0000000000001F00ULL, 0x0000000000003F00ULL, 0x0000000000007F00ULL,
	0x0000000000000000ULL, 0x0000000000010000ULL, 0x0000000000030000ULL, 0x0000000000070000ULL,
	0x00000000000F0000ULL, 0x00000000001F0000ULL, 0x00000000003F0000ULL, 0x00000000007F0000ULL,
	0x0000000000000000ULL, 0x0000000001000000ULL, 0x0000000003000000ULL, 0x0000000007000000ULL,
	0x000000000F000000ULL, 0x000000001F000000ULL, 0x000000003F000000ULL, 0x000000007F000000ULL,
	0x0000000000000000ULL, 0x0000000100000000ULL, 0x0000000300000000ULL, 0x0000000700000000ULL,
	0x0000000F00000000ULL, 0x0000001F00000000ULL, 0x0000003F00000000ULL, 0x0000007F00000000ULL,
	0x0000000000000000ULL, 0x0000010000000000ULL, 0x0000030000000000ULL, 0x0000070000000000ULL,
	0x00000F0000000000ULL, 0x00001F0000000000ULL, 0x00003F0000000000ULL, 0x00007F0000000000ULL,
	0x0000000000000000ULL, 0x0001000000000000ULL, 0x0003000000000000ULL, 0x0007000000000000ULL,
	0x000F000000000000ULL, 0x001F000000000000ULL, 0x003F000000000000ULL, 0x007F000000000000ULL,
	0x0000000000000000ULL, 0x0100000000000000ULL, 0x0300000000000000ULL, 0x0700000000000000ULL,
	0x0F00000000000000ULL, 0x1F00000000000000ULL, 0x3F00000000000000ULL, 0x7F00000000000000ULL

};

uint64_t RayAttacksNE[64] = {
	0x8040201008040200ULL, 0x0080402010080400ULL, 0x0000804020100800ULL, 0x0000008040201000ULL,
	0x0000000080402000ULL, 0x0000000000804000ULL, 0x0000000000008000ULL, 0x0000000000000000ULL,
	0x4020100804020000ULL, 0x8040201008040000ULL, 0x0080402010080000ULL, 0x0000804020100000ULL,
	0x0000008040200000ULL, 0x0000000080400000ULL, 0x0000000000800000ULL, 0x0000000000000000ULL,
	0x2010080402000000ULL, 0x4020100804000000ULL, 0x8040201008000000ULL, 0x0080402010000000ULL,
	0x0000804020000000ULL, 0x0000008040000000ULL, 0x0000000080000000ULL, 0x0000000000000000ULL,
	0x1008040200000000ULL, 0x2010080400000000ULL, 0x4020100800000000ULL, 0x8040201000000000ULL,
	0x0080402000000000ULL, 0x0000804000000000ULL, 0x0000008000000000ULL, 0x0000000000000000ULL,
	0x0804020000000000ULL, 0x1008040000000000ULL, 0x2010080000000000ULL, 0x4020100000000000ULL,
	0x8040200000000000ULL, 0x0080400000000000ULL, 0x0000800000000000ULL, 0x0000000000000000ULL,
	0x0402000000000000ULL, 0x0804000000000000ULL, 0x1008000000000000ULL, 0x2010000000000000ULL,
	0x4020000000000000ULL, 0x8040000000000000ULL, 0x0080000000000000ULL, 0x0000000000000000ULL,
	0x0200000000000000ULL, 0x0400000000000000ULL, 0x0800000000000000ULL, 0x1000000000000000ULL,
	0x2000000000000000ULL, 0x4000000000000000ULL, 0x8000000000000000ULL, 0x0000000000000000ULL,
	0x0000000000000000ULL, 0x0000000000000000ULL, 0x0000000000000000ULL, 0x0000000000000000ULL,
	0x0000000000000000ULL, 0x0000000000000000ULL, 0x0000000000000000ULL, 0x0000000000000000ULL

};

uint64_t RayAttacksNW[64] = {
	0x0000000000000000ULL, 0x0000000000000100ULL, 0x0000000000010200ULL, 0x0000000001020400ULL,
	0x0000000102040800ULL, 0x0000010204081000ULL, 0x0001020408102000ULL, 0x0102040810204000ULL,
	0x0000000000000000ULL, 0x0000000000010000ULL, 0x0000000001020000ULL, 0x0000000102040000ULL,
	0x0000010204080000ULL, 0x0001020408100000ULL, 0x0102040810200000ULL, 0x0204081020400000ULL,
	0x0000000000000000ULL, 0x0000000001000000ULL, 0x0000000102000000ULL, 0x0000010204000000ULL,
	0x0001020408000000ULL, 0x0102040810000000ULL, 0x0204081020000000ULL, 0x0408102040000000ULL,
	0x0000000000000000ULL, 0x0000000100000000ULL, 0x0000010200000000ULL, 0x0001020400000000ULL,
	0x0102040800000000ULL, 0x0204081000000000ULL, 0x0408102000000000ULL, 0x0810204000000000ULL,
	0x0000000000000000ULL, 0x0000010000000000ULL, 0x0001020000000000ULL, 0x0102040000000000ULL,
	0x0204080000000000ULL, 0x0408100000000000ULL, 0x0810200000000000ULL, 0x1020400000000000ULL,
	0x0000000000000000ULL, 0x0001000000000000ULL, 0x0102000000000000ULL, 0x0204000000000000ULL,
	0x0408000000000000ULL, 0x0810000000000000ULL, 0x1020000000000000ULL, 0x2040000000000000ULL,
	0x0000000000000000ULL, 0x0100000000000000ULL, 0x0200000000000000ULL, 0x0400000000000000ULL,
	0x0800000000000000ULL, 0x1000000000000000ULL, 0x2000000000000000ULL, 0x4000000000000000ULL,
	0x0000000000000000ULL, 0x0000000000000000ULL, 0x0000000000000000ULL, 0x0000000000000000ULL,
	0x0000000000000000ULL, 0x0000000000000000ULL, 0x0000000000000000ULL, 0x0000000000000000ULL

};

uint64_t RayAttacksSE[64] = {
	0x0000000000000000ULL, 0x0000000000000000ULL, 0x0000000000000000ULL, 0x0000000000000000ULL,
	0x0000000000000000ULL, 0x0000000000000000ULL, 0x0000000000000000ULL, 0x0000000000000000ULL,
	0x0000000000000002ULL, 0x0000000000000004ULL, 0x0000000000000008ULL, 0x0000000000000010ULL,
	0x0000000000000020ULL, 0x0000000000000040ULL, 0x0000000000000080ULL, 0x0000000000000000ULL,
	0x0000000000000204ULL, 0x0000000000000408ULL, 0x0000000000000810ULL, 0x0000000000001020ULL,
	0x0000000000002040ULL, 0x0000000000004080ULL, 0x0000000000008000ULL, 0x0000000000000000ULL,
	0x0000000000020408ULL, 0x0000000000040810ULL, 0x0000000000081020ULL, 0x0000000000102040ULL,
	0x0000000000204080ULL, 0x0000000000408000ULL, 0x0000000000800000ULL, 0x0000000000000000ULL,
	0x0000000002040810ULL, 0x0000000004081020ULL, 0x0000000008102040ULL, 0x0000000010204080ULL,
	0x0000000020408000ULL, 0x0000000040800000ULL, 0x0000000080000000ULL, 0x0000000000000000ULL,
	0x0000000204081020ULL, 0x0000000408102040ULL, 0x0000000810204080ULL, 0x0000001020408000ULL,
	0x0000002040800000ULL, 0x0000004080000000ULL, 0x0000008000000000ULL, 0x0000000000000000ULL,
	0x0000020408102040ULL, 0x0000040810204080ULL, 0x0000081020408000ULL, 0x0000102040800000ULL,
	0x0000204080000000ULL, 0x0000408000000000ULL, 0x0000800000000000ULL, 0x0000000000000000ULL,
	0x0002040810204080ULL, 0x0004081020408000ULL, 0x0008102040800000ULL, 0x0010204080000000ULL,
	0x0020408000000000ULL, 0x0040800000000000ULL, 0x0080000000000000ULL, 0x0000000000000000ULL

};

uint64_t RayAttacksSW[64] = {
	0x0000000000000000ULL, 0x0000000000000000ULL, 0x0000000000000000ULL, 0x0000000000000000ULL,
	0x0000000000000000ULL, 0x0000000000000000ULL, 0x0000000000000000ULL, 0x0000000000000000ULL,
	0x0000000000000000ULL, 0x0000000000000001ULL, 0x0000000000000002ULL, 0x0000000000000004ULL,
	0x0000000000000008ULL, 0x0000000000000010ULL, 0x0000000000000020ULL, 0x0000000000000040ULL,
	0x0000000000000000ULL, 0x0000000000000100ULL, 0x0000000000000201ULL, 0x0000000000000402ULL,
	0x0000000000000804ULL, 0x0000000000001008ULL, 0x0000000000002010ULL, 0x0000000000004020ULL,
	0x0000000000000000ULL, 0x0000000000010000ULL, 0x0000000000020100ULL, 0x0000000000040201ULL,
	0x0000000000080402ULL, 0x0000000000100804ULL, 0x0000000000201008ULL, 0x0000000000402010ULL,
	0x0000000000000000ULL, 0x0000000001000000ULL, 0x0000000002010000ULL, 0x0000000004020100ULL,
	0x0000000008040201ULL, 0x0000000010080402ULL, 0x0000000020100804ULL, 0x0000000040201008ULL,
	0x0000000000000000ULL, 0x0000000100000000ULL, 0x0000000201000000ULL, 0x0000000402010000ULL,
	0x0000000804020100ULL, 0x0000001008040201ULL, 0x0000002010080402ULL, 0x0000004020100804ULL,
	0x0000000000000000ULL, 0x0000010000000000ULL, 0x0000020100000000ULL, 0x0000040201000000ULL,
	0x0000080402010000ULL, 0x0000100804020100ULL, 0x0000201008040201ULL, 0x0000402010080402ULL,
	0x0000000000000000ULL, 0x0001000000000000ULL, 0x0002010000000000ULL, 0x0004020100000000ULL,
	0x0008040201000000ULL, 0x0010080402010000ULL, 0x0020100804020100ULL, 0x0040201008040201ULL

};

std::vector<Move> MoveGenerator::GenerateMoves(Board& position, PieceRank rankFilter)
{
	uint64_t pieces = position.ColorToMove == PieceColor::WHITE ? position.WhitePieces : position.BlackPieces;
	uint64_t currentPiece;
	PieceRank rank;
	bool inCheck = false;

	moveList.clear();

	if (IsSquareAttacked(position.ColorToMove ==
		PieceColor::WHITE ? position.WhiteKing : position.BlackKing, position))
	{
		inCheck = true;
	}

	if (rankFilter == PieceRank::PAWN)
	{
		pieces = pieces & (position.WhitePawns | position.BlackPawns);
	}
	else if (rankFilter == PieceRank::KNIGHT)
	{
		pieces = pieces & (position.WhiteKnights | position.BlackKnights);
	}
	else if (rankFilter == PieceRank::BISHOP)
	{
		pieces = pieces & (position.WhiteBishops | position.BlackBishops);
	}
	else if (rankFilter == PieceRank::ROOK)
	{
		pieces = pieces & (position.WhiteRooks | position.BlackRooks);
	}
	else if (rankFilter == PieceRank::QUEEN)
	{
		pieces = pieces & (position.WhiteQueens | position.BlackQueens);
	}
	else if (rankFilter == PieceRank::KING)
	{
		pieces = pieces & (position.WhiteKing | position.BlackKing);
	}

	while (pieces != 0x0000000000000000ULL)
	{
		currentPiece = 0x0000000000000001ULL << GetLSB(pieces);
		rank = GetRankAt(position, currentPiece);

		if (rank == PieceRank::KNIGHT)
		{
			if (!IsPiecePinnedFile(position, currentPiece)
				&& !IsPiecePinnedRank(position, currentPiece)
				&& !IsPiecePinnedNWSE(position, currentPiece)
				&& !IsPiecePinnedSWNE(position, currentPiece))
			{
				GenerateKnightMovesAt(currentPiece, position, inCheck);
			}
		}
		else if (rank == PieceRank::BISHOP)
		{
			if (!IsPiecePinnedFile(position, currentPiece)
				&& !IsPiecePinnedRank(position, currentPiece))
			{
				if (!IsPiecePinnedNWSE(position, currentPiece))
				{
					GenerateSlidingMovesAt(position, currentPiece, 0x02, inCheck);
					GenerateSlidingMovesAt(position, currentPiece, 0x20, inCheck);
				}

				if (!IsPiecePinnedSWNE(position, currentPiece))
				{
					GenerateSlidingMovesAt(position, currentPiece, 0x08, inCheck);
					GenerateSlidingMovesAt(position, currentPiece, 0x80, inCheck);
				}
			}
		}
		else if (rank == PieceRank::ROOK)
		{
			if (!IsPiecePinnedNWSE(position, currentPiece)
				&& !IsPiecePinnedSWNE(position, currentPiece))
			{
				if (!IsPiecePinnedRank(position, currentPiece))
				{
					GenerateSlidingMovesAt(position, currentPiece, 0x01, inCheck);
					GenerateSlidingMovesAt(position, currentPiece, 0x10, inCheck);
				}

				if (!IsPiecePinnedFile(position, currentPiece))
				{
					GenerateSlidingMovesAt(position, currentPiece, 0x04, inCheck);
					GenerateSlidingMovesAt(position, currentPiece, 0x40, inCheck);
				}
			}
		}
		else if (rank == PieceRank::QUEEN)
		{
			if (!IsPiecePinnedNWSE(position, currentPiece)
				&& !IsPiecePinnedSWNE(position, currentPiece))
			{
				if (!IsPiecePinnedRank(position, currentPiece))
				{
					GenerateSlidingMovesAt(position, currentPiece, 0x01, inCheck);
					GenerateSlidingMovesAt(position, currentPiece, 0x10, inCheck);
				}

				if (!IsPiecePinnedFile(position, currentPiece))
				{
					GenerateSlidingMovesAt(position, currentPiece, 0x04, inCheck);
					GenerateSlidingMovesAt(position, currentPiece, 0x40, inCheck);
				}
			}

			if (!IsPiecePinnedFile(position, currentPiece)
				&& !IsPiecePinnedRank(position, currentPiece))
			{
				if (!IsPiecePinnedNWSE(position, currentPiece))
				{
					GenerateSlidingMovesAt(position, currentPiece, 0x02, inCheck);
					GenerateSlidingMovesAt(position, currentPiece, 0x20, inCheck);
				}

				if (!IsPiecePinnedSWNE(position, currentPiece))
				{
					GenerateSlidingMovesAt(position, currentPiece, 0x08, inCheck);
					GenerateSlidingMovesAt(position, currentPiece, 0x80, inCheck);
				}
			}
		}
		else if (rank == PieceRank::KING)
		{
			GenerateKingMovesAt(currentPiece, position, inCheck);
		}
		else if (rank == PieceRank::PAWN)
		{
			GeneratePawnMovesAt(currentPiece, position, inCheck);
		}

		pieces = pieces & ~currentPiece;
	}

	return moveList;
}

bool MoveGenerator::IsPiecePinned(Board& position, uint64_t location, int offset)
{
	bool result = true;
	int locationMaskIndex;
	PieceColor pinningColor =
		Position::GetColorAt(position, location) == PieceColor::WHITE ? PieceColor::BLACK : PieceColor::WHITE;
	uint64_t pinMask;
	uint64_t pinnedKingLocation;
	uint64_t mask;
	uint64_t occupancy;
	uint64_t tmpLocation;
	uint64_t guard;
	bool goUp;

	if (PopCount(location) == 1)
	{
		if (pinningColor == PieceColor::WHITE)
		{
			if (offset == 8 || offset == 1)
			{
				pinMask = position.WhiteQueens | position.WhiteRooks;
			}
			else
			{
				pinMask = position.WhiteQueens | position.WhiteBishops;
			}

			pinnedKingLocation = position.BlackKing;
		}
		else
		{
			if (offset == 8 || offset == 1)
			{
				pinMask = position.BlackQueens | position.BlackRooks;
			}
			else
			{
				pinMask = position.BlackQueens | position.BlackBishops;
			}

			pinnedKingLocation = position.WhiteKing;
		}

		locationMaskIndex = GetLSB(location);

		if (offset == 8)
		{
			mask = FileMask[locationMaskIndex];
		}
		else if (offset == 1)
		{
			mask = RankMask[locationMaskIndex];
		}
		else if (offset == 9)
		{
			mask = SWNEMask[locationMaskIndex];
		}
		else if (offset == 7)
		{
			mask = NWSEMask[locationMaskIndex];
		}
		else
		{
			mask = 0x0000000000000000UL;
		}

		if ((GetColorAt(position, location) == PieceColor::WHITE
			&& (mask & pinnedKingLocation) != 0x0000000000000000UL
			&& (mask & pinMask) != 0x0000000000000000UL)
			|| (GetColorAt(position, location) == PieceColor::BLACK
				&& (mask & pinnedKingLocation) != 0x0000000000000000UL
				&& (mask & pinMask) != 0x0000000000000000UL))
		{

			occupancy = (position.WhitePieces | position.BlackPieces) & mask;

			if (pinnedKingLocation < location)
			{
				goUp = true;

				if (offset == 9)
				{
					guard = 0x007F7F7F7F7F7F7FUL;
				}
				else if (offset == 1)
				{
					guard = 0x7F7F7F7F7F7F7F7FUL;
				}
				else if (offset == 8)
				{
					guard = 0x00FFFFFFFFFFFFFFUL;
				}
				else if (offset == 7)
				{
					guard = 0x00FEFEFEFEFEFEFEUL;
				}
				else
				{
					guard = 0x0000000000000000UL;
				}
			}
			else
			{
				goUp = false;

				if (offset == 9)
				{
					guard = 0xFEFEFEFEFEFEFE00UL;
				}
				else if (offset == 1)
				{
					guard = 0xFEFEFEFEFEFEFEFEUL;
				}
				else if (offset == 8)
				{
					guard = 0xFFFFFFFFFFFFFF00UL;
				}
				else if (offset == 7)
				{
					guard = 0x7F7F7F7F7F7F7F00UL;
				}
				else
				{
					guard = 0x0000000000000000UL;
				}
			}

			if ((pinnedKingLocation & guard) != 0x0000000000000000UL)
			{
				tmpLocation = goUp ? pinnedKingLocation << offset : pinnedKingLocation >> offset;

				while (tmpLocation != location)
				{
					if ((tmpLocation & occupancy) != 0x0000000000000000UL)
					{
						result = false;
						break;
					}

					tmpLocation = goUp ? tmpLocation << offset : tmpLocation >> offset;
				}

				if (result && (tmpLocation & guard) != 0x0000000000000000UL)
				{
					tmpLocation = goUp ? tmpLocation << offset : tmpLocation >> offset;

					while (true)
					{
						if ((tmpLocation & occupancy) != 0x0000000000000000UL)
						{
							if ((tmpLocation & pinMask) == 0x0000000000000000UL)
							{
								result = false;
								break;
							}
							else
							{
								break;
							}
						}
						else
						{
							if ((tmpLocation & guard) != 0x0000000000000000UL)
							{
								tmpLocation = goUp ? tmpLocation << offset : tmpLocation >> offset;
							}
							else
							{
								result = false;
								break;
							}
						}
					}
				}
				else
				{
					result = false;
				}
			}
			else
			{
				result = false;
			}
		}
		else
		{
			result = false;
		}
	}
	else
	{
		result = false;
	}

	return result;
}

bool MoveGenerator::IsPiecePinnedNWSE(Board& position, uint64_t location)
{
	return IsPiecePinned(position, location, 7);
}

bool MoveGenerator::IsPiecePinnedSWNE(Board& position, uint64_t location)
{
	return IsPiecePinned(position, location, 9);
}

bool MoveGenerator::IsPiecePinnedRank(Board& position, uint64_t location)
{
	return IsPiecePinned(position, location, 1);
}

bool MoveGenerator::IsPiecePinnedFile(Board& position, uint64_t location)
{
	return IsPiecePinned(position, location, 8);
}

void MoveGenerator::GenerateSlidingMovesAt(Board& position, uint64_t location,
	uint16_t direction, bool evade)
{
	int locationIndex;
	uint64_t moveMask = 0x0000000000000000ULL;
	uint64_t currentMove;
	PieceColor color = GetColorAt(position, location);
	uint64_t opposingPieces = color == PieceColor::WHITE ? position.BlackPieces : position.WhitePieces;
	uint64_t ownPieces = color == PieceColor::WHITE ? position.WhitePieces : position.BlackPieces;
	int blockerIndex;

	if (PopCount(location) == 1)
	{
		locationIndex = GetLSB(location);

		if (direction == 0x01)
		{
			moveMask = RayAttacksN[locationIndex];
			blockerIndex = GetLSB(moveMask & (position.WhitePieces | position.BlackPieces));

			if (blockerIndex != -1)
			{
				moveMask = moveMask & ~RayAttacksN[blockerIndex];
				moveMask = moveMask & ~ownPieces;
			}
		}
		else if (direction == 0x02)
		{
			moveMask = RayAttacksNE[locationIndex];
			blockerIndex = GetLSB(moveMask & (position.WhitePieces | position.BlackPieces));

			if (blockerIndex != -1)
			{
				moveMask = moveMask & ~RayAttacksNE[blockerIndex];
				moveMask = moveMask & ~ownPieces;
			}
		}
		else if (direction == 0x04)
		{
			moveMask = RayAttacksE[locationIndex];
			blockerIndex = GetLSB(moveMask & (position.WhitePieces | position.BlackPieces));

			if (blockerIndex != -1)
			{
				moveMask = moveMask & ~RayAttacksE[blockerIndex];
				moveMask = moveMask & ~ownPieces;
			}
		}
		else if (direction == 0x08)
		{
			moveMask = RayAttacksSE[locationIndex];
			blockerIndex = GetMSB(moveMask & (position.WhitePieces | position.BlackPieces));

			if (blockerIndex != -1)
			{
				moveMask = moveMask & ~RayAttacksSE[blockerIndex];
				moveMask = moveMask & ~ownPieces;
			}
		}
		else if (direction == 0x10)
		{
			moveMask = RayAttacksS[locationIndex];
			blockerIndex = GetMSB(moveMask & (position.WhitePieces | position.BlackPieces));

			if (blockerIndex != -1)
			{
				moveMask = moveMask & ~RayAttacksS[blockerIndex];
				moveMask = moveMask & ~ownPieces;
			}
		}
		else if (direction == 0x20)
		{
			moveMask = RayAttacksSW[locationIndex];
			blockerIndex = GetMSB(moveMask & (position.WhitePieces | position.BlackPieces));

			if (blockerIndex != -1)
			{
				moveMask = moveMask & ~RayAttacksSW[blockerIndex];
				moveMask = moveMask & ~ownPieces;
			}
		}
		else if (direction == 0x40)
		{
			moveMask = RayAttacksW[locationIndex];
			blockerIndex = GetMSB(moveMask & (position.WhitePieces | position.BlackPieces));

			if (blockerIndex != -1)
			{
				moveMask = moveMask & ~RayAttacksW[blockerIndex];
				moveMask = moveMask & ~ownPieces;
			}
		}
		else if (direction == 0x80)
		{
			moveMask = RayAttacksNW[locationIndex];
			blockerIndex = GetLSB(moveMask & (position.WhitePieces | position.BlackPieces));

			if (blockerIndex != -1)
			{
				moveMask = moveMask & ~RayAttacksNW[blockerIndex];
				moveMask = moveMask & ~ownPieces;
			}
		}
	}

	while (moveMask != 0x0000000000000000ULL)
	{
		currentMove = 0x0000000000000001ULL << GetLSB(moveMask);
		PieceRank captured = PieceRank::NONE;

		if ((opposingPieces & currentMove) != 0x0000000000000000ULL)
		{
			captured = GetRankAt(position, currentMove);
		}

		AddMove(location, currentMove, GetRankAt(position, location),
			color, position.HalfMoveCounter, position.CastlingStatus,
			position.EnPassantTarget, captured, PieceRank::NONE, evade, position);

		moveMask = moveMask & ~currentMove;
	}
}

void MoveGenerator::GeneratePawnMovesAt(uint64_t location, Board& position, bool evade)
{
	uint64_t advancedLocation = position.ColorToMove == PieceColor::WHITE ? location << 8 : location >> 8;
	uint64_t doubleAdvancedLocation =
		position.ColorToMove == PieceColor::WHITE ? location << 16 : location >> 16;

	uint64_t captureLeftLocation =
		position.ColorToMove == PieceColor::WHITE ? location << 7 : location >> 7;

	uint64_t captureRightLocation =
		position.ColorToMove == PieceColor::WHITE ? location << 9 : location >> 9;

	uint64_t startRankMask =
		position.ColorToMove == PieceColor::WHITE ? 0x000000000000FF00UL : 0x00FF000000000000UL;

	uint64_t backRankMask =
		position.ColorToMove == PieceColor::WHITE ? 0xFF00000000000000UL : 0x00000000000000FFUL;

	uint64_t leftEdgeMask =
		position.ColorToMove == PieceColor::WHITE ? 0x0101010101010101UL : 0x8080808080808080UL;

	uint64_t rightEdgeMask =
		position.ColorToMove == PieceColor::WHITE ? 0x8080808080808080UL : 0x0101010101010101UL;

	uint64_t opposingPieces =
		position.ColorToMove == PieceColor::WHITE ? position.BlackPieces : position.WhitePieces;

	if (!IsPiecePinnedRank(position, location))
	{
		if (!IsPiecePinnedNWSE(position, location)
			&& !IsPiecePinnedSWNE(position, location))
		{
			if (((advancedLocation & (position.WhitePieces | position.BlackPieces)) == 0x0000000000000000UL)
				&& ((doubleAdvancedLocation & (position.WhitePieces | position.BlackPieces))
					== 0x0000000000000000UL)
				&& (location & startRankMask) == location)
			{
				AddMove(location, doubleAdvancedLocation, PieceRank::PAWN, position.ColorToMove,
					position.HalfMoveCounter, position.CastlingStatus, position.EnPassantTarget, PieceRank::NONE,
					PieceRank::NONE, evade, position);
			}

			if (((location & backRankMask) == 0x0000000000000000UL)
				&& ((advancedLocation & (position.WhitePieces | position.BlackPieces)) == 0x0000000000000000UL))
			{
				if ((advancedLocation & backRankMask) == 0x0000000000000000UL)
				{
					AddMove(location, advancedLocation, PieceRank::PAWN, position.ColorToMove,
						position.HalfMoveCounter, position.CastlingStatus, position.EnPassantTarget, PieceRank::NONE,
						PieceRank::NONE, evade, position);
				}
				else
				{
					AddMove(location, advancedLocation, PieceRank::PAWN, position.ColorToMove,
						position.HalfMoveCounter, position.CastlingStatus, position.EnPassantTarget, PieceRank::NONE,
						PieceRank::QUEEN, evade, position);

					AddMove(location, advancedLocation, PieceRank::PAWN, position.ColorToMove,
						position.HalfMoveCounter, position.CastlingStatus, position.EnPassantTarget, PieceRank::NONE,
						PieceRank::ROOK, evade, position);

					AddMove(location, advancedLocation, PieceRank::PAWN, position.ColorToMove,
						position.HalfMoveCounter, position.CastlingStatus, position.EnPassantTarget, PieceRank::NONE,
						PieceRank::BISHOP, evade, position);

					AddMove(location, advancedLocation, PieceRank::PAWN, position.ColorToMove,
						position.HalfMoveCounter, position.CastlingStatus, position.EnPassantTarget, PieceRank::NONE,
						PieceRank::KNIGHT, evade, position);
				}
			}
		}

		if (!IsPiecePinnedFile(position, location))
		{
			bool isPinned = false;

			if (position.ColorToMove == PieceColor::WHITE && IsPiecePinnedSWNE(position, location))
			{
				isPinned = true;
			}

			if (position.ColorToMove == PieceColor::BLACK && IsPiecePinnedSWNE(position, location))
			{
				isPinned = true;
			}

			if (!isPinned)
			{
				if (((location & (leftEdgeMask | backRankMask)) == 0x0000000000000000UL)
					&& ((captureLeftLocation & (opposingPieces | position.EnPassantTarget)) != 0x0000000000000000UL))
				{
					PieceRank captured = GetRankAt(position, captureLeftLocation);

					if ((captureLeftLocation & position.EnPassantTarget) != 0x0000000000000000UL)
					{
						evade = true;
						captured = PieceRank::PAWN;
					}

					if ((captureLeftLocation & backRankMask) == 0x0000000000000000UL)
					{
						AddMove(location, captureLeftLocation, PieceRank::PAWN,
							position.ColorToMove, position.HalfMoveCounter, position.CastlingStatus,
							position.EnPassantTarget, captured, PieceRank::NONE,
							evade, position);
					}
					else
					{
						AddMove(location, captureLeftLocation, PieceRank::PAWN,
							position.ColorToMove, position.HalfMoveCounter, position.CastlingStatus,
							position.EnPassantTarget, captured, PieceRank::QUEEN,
							evade, position);

						AddMove(location, captureLeftLocation, PieceRank::PAWN,
							position.ColorToMove, position.HalfMoveCounter, position.CastlingStatus,
							position.EnPassantTarget, captured, PieceRank::ROOK,
							evade, position);

						AddMove(location, captureLeftLocation, PieceRank::PAWN,
							position.ColorToMove, position.HalfMoveCounter, position.CastlingStatus,
							position.EnPassantTarget, captured, PieceRank::BISHOP,
							evade, position);

						AddMove(location, captureLeftLocation, PieceRank::PAWN,
							position.ColorToMove, position.HalfMoveCounter, position.CastlingStatus,
							position.EnPassantTarget, captured, PieceRank::KNIGHT,
							evade, position);
					}
				}
			}

			isPinned = false;

			if (position.ColorToMove == PieceColor::WHITE && IsPiecePinnedNWSE(position, location))
			{
				isPinned = true;
			}

			if (position.ColorToMove == PieceColor::BLACK && IsPiecePinnedNWSE(position, location))
			{
				isPinned = true;
			}

			if (!isPinned)
			{
				if (((location & (rightEdgeMask | backRankMask)) == 0x0000000000000000UL)
					&& ((captureRightLocation & (opposingPieces | position.EnPassantTarget)) != 0x0000000000000000UL))
				{
					PieceRank captured = GetRankAt(position, captureRightLocation);

					if ((captureRightLocation & position.EnPassantTarget) != 0x0000000000000000UL)
					{
						evade = true;
						captured = PieceRank::PAWN;
					}

					if ((captureRightLocation & backRankMask) == 0x0000000000000000UL)
					{
						AddMove(location, captureRightLocation, PieceRank::PAWN,
							position.ColorToMove, position.HalfMoveCounter, position.CastlingStatus,
							position.EnPassantTarget, captured, PieceRank::NONE,
							evade, position);
					}
					else
					{
						AddMove(location, captureRightLocation, PieceRank::PAWN,
							position.ColorToMove, position.HalfMoveCounter, position.CastlingStatus,
							position.EnPassantTarget, captured, PieceRank::QUEEN,
							evade, position);

						AddMove(location, captureRightLocation, PieceRank::PAWN,
							position.ColorToMove, position.HalfMoveCounter, position.CastlingStatus,
							position.EnPassantTarget, captured, PieceRank::ROOK,
							evade, position);

						AddMove(location, captureRightLocation, PieceRank::PAWN,
							position.ColorToMove, position.HalfMoveCounter, position.CastlingStatus,
							position.EnPassantTarget, captured, PieceRank::BISHOP,
							evade, position);

						AddMove(location, captureRightLocation, PieceRank::PAWN,
							position.ColorToMove, position.HalfMoveCounter, position.CastlingStatus,
							position.EnPassantTarget, captured, PieceRank::KNIGHT,
							evade, position);
					}
				}
			}
		}
	}
}

void MoveGenerator::GenerateKnightMovesAt(uint64_t location, Board& position, bool evade)
{
	int locationIndex;
	uint64_t moveMask = 0x0000000000000000ULL;
	uint64_t currentMove;
	PieceColor color = GetColorAt(position, location);
	uint64_t opposingPieces = color == PieceColor::WHITE ? position.BlackPieces : position.WhitePieces;
	uint64_t ownPieces = color == PieceColor::WHITE ? position.WhitePieces : position.BlackPieces;


	if (PopCount(location) == 1)
	{
		locationIndex = GetLSB(location);

		moveMask = KnightAttacks[locationIndex] & ~ownPieces;
	}

	while (moveMask != 0x0000000000000000ULL)
	{
		currentMove = 0x0000000000000001ULL << GetLSB(moveMask);
		PieceRank captured = PieceRank::NONE;

		if ((opposingPieces & currentMove) != 0x0000000000000000ULL)
		{
			captured = GetRankAt(position, currentMove);
		}

		AddMove(location, currentMove, PieceRank::KNIGHT, color, position.HalfMoveCounter,
			position.CastlingStatus, position.EnPassantTarget, captured, PieceRank::NONE, evade, position);

		moveMask = moveMask & ~currentMove;
	}
}

void MoveGenerator::GenerateKingMovesAt(uint64_t location, Board& position, bool evade)
{
	int locationIndex;
	uint64_t moveMask = 0x0000000000000000ULL;
	uint64_t currentMove;
	PieceColor color = GetColorAt(position, location);
	uint64_t opposingPieces = color == PieceColor::WHITE ? position.BlackPieces : position.WhitePieces;
	uint64_t ownPieces = color == PieceColor::WHITE ? position.WhitePieces : position.BlackPieces;


	if (PopCount(location) == 1)
	{
		locationIndex = GetLSB(location);

		moveMask = KingAttacks[locationIndex] & ~ownPieces;
	}

	while (moveMask != 0x0000000000000000ULL)
	{
		currentMove = 0x0000000000000001ULL << GetLSB(moveMask);

		if (!IsSquareAttacked(currentMove, position))
		{
			PieceRank captured = PieceRank::NONE;

			if ((opposingPieces & currentMove) != 0x0000000000000000ULL)
			{
				captured = GetRankAt(position, currentMove);
			}

			AddMove(location, currentMove, PieceRank::KING, color, position.HalfMoveCounter,
				position.CastlingStatus, position.EnPassantTarget, captured, PieceRank::NONE, evade, position);
		}

		moveMask = moveMask & ~currentMove;
	}

	if (color == PieceColor::WHITE)
	{
		if ((position.CastlingStatus & CastlingFlags::WHITE_SHORT) != 0)
		{
			if (((position.WhitePieces | position.BlackPieces) & 0x0000000000000060ULL)
				== 0x0000000000000000UL)
			{
				if (!IsSquareAttacked(0x0000000000000040ULL, position)
					&& !IsSquareAttacked(0x0000000000000020ULL, position)
					&& !IsSquareAttacked(0x0000000000000010ULL, position))
				{
					AddMove(0x0000000000000010ULL, 0x0000000000000040ULL, PieceRank::KING, color,
						position.HalfMoveCounter, position.CastlingStatus, position.EnPassantTarget,
						PieceRank::NONE, PieceRank::NONE, evade, position);
				}
			}
		}

		if ((position.CastlingStatus & CastlingFlags::WHITE_LONG) != 0)
		{
			if (((position.WhitePieces | position.BlackPieces) & 0x000000000000000EULL)
				== 0x0000000000000000ULL)
			{
				if (!IsSquareAttacked(0x0000000000000008ULL, position)
					&& !IsSquareAttacked(0x0000000000000004ULL, position)
					&& !IsSquareAttacked(0x0000000000000010ULL, position))
				{
					AddMove(0x0000000000000010ULL, 0x0000000000000004ULL, PieceRank::KING, color,
						position.HalfMoveCounter, position.CastlingStatus, position.EnPassantTarget,
						PieceRank::NONE, PieceRank::NONE, evade, position);
				}
			}
		}
	}
	else
	{
		if ((position.CastlingStatus & CastlingFlags::BLACK_SHORT) != 0)
		{
			if (((position.WhitePieces | position.BlackPieces) & 0x6000000000000000ULL)
				== 0x0000000000000000ULL)
			{
				if (!IsSquareAttacked(0x4000000000000000ULL, position)
					&& !IsSquareAttacked(0x2000000000000000ULL, position)
					&& !IsSquareAttacked(0x1000000000000000ULL, position))
				{
					AddMove(0x1000000000000000ULL, 0x4000000000000000ULL, PieceRank::KING, color,
						position.HalfMoveCounter, position.CastlingStatus, position.EnPassantTarget,
						PieceRank::NONE, PieceRank::NONE, evade, position);
				}
			}
		}

		if ((position.CastlingStatus & CastlingFlags::BLACK_LONG) != 0)
		{
			if (((position.WhitePieces | position.BlackPieces) & 0x0E00000000000000ULL)
				== 0x0000000000000000ULL)
			{
				if (!IsSquareAttacked(0x0800000000000000ULL, position)
					&& !IsSquareAttacked(0x0400000000000000ULL, position)
					&& !IsSquareAttacked(0x1000000000000000ULL, position))
				{
					AddMove(0x1000000000000000ULL, 0x0400000000000000ULL, PieceRank::KING, color,
						position.HalfMoveCounter, position.CastlingStatus, position.EnPassantTarget,
						PieceRank::NONE, PieceRank::NONE, evade, position);
				}
			}
		}
	}
}

bool MoveGenerator::IsSquareAttacked(uint64_t square, Board& position)
{
	bool result = false;
	int squareIndex = GetLSB(square);
	int blockerIndex;
	uint64_t opposingKnights =
		position.ColorToMove == PieceColor::WHITE ? position.BlackKnights : position.WhiteKnights;
	uint64_t opposingBishops =
		position.ColorToMove == PieceColor::WHITE ? position.BlackBishops : position.WhiteBishops;
	uint64_t opposingRooks =
		position.ColorToMove == PieceColor::WHITE ? position.BlackRooks : position.WhiteRooks;
	uint64_t opposingQueens =
		position.ColorToMove == PieceColor::WHITE ? position.BlackQueens : position.WhiteQueens;


	if ((KnightAttacks[squareIndex] & opposingKnights) != 0x0000000000000000ULL)
	{
		result = true;
	}

	blockerIndex = GetLSB(RayAttacksN[squareIndex] & (position.WhitePieces | position.BlackPieces));

	if (blockerIndex != -1)
	{
		if (((0x0000000000000001ULL << blockerIndex) & (opposingRooks | opposingQueens))
			!= 0x0000000000000000ULL)
		{
			result = true;
		}
	}

	blockerIndex = GetLSB(RayAttacksNE[squareIndex] & (position.WhitePieces | position.BlackPieces));

	if (blockerIndex != -1)
	{
		if (((0x0000000000000001ULL << blockerIndex) & (opposingBishops | opposingQueens))
			!= 0x0000000000000000ULL)
		{
			result = true;
		}
	}

	blockerIndex = GetLSB(RayAttacksE[squareIndex] & (position.WhitePieces | position.BlackPieces));

	if (blockerIndex != -1)
	{
		if (((0x0000000000000001ULL << blockerIndex) & (opposingRooks | opposingQueens))
			!= 0x0000000000000000ULL)
		{
			result = true;
		}
	}

	blockerIndex = GetMSB(RayAttacksSE[squareIndex] & (position.WhitePieces | position.BlackPieces));

	if (blockerIndex != -1)
	{
		if (((0x0000000000000001ULL << blockerIndex) & (opposingBishops | opposingQueens))
			!= 0x0000000000000000ULL)
		{
			result = true;
		}
	}

	blockerIndex = GetMSB(RayAttacksS[squareIndex] & (position.WhitePieces | position.BlackPieces));

	if (blockerIndex != -1)
	{
		if (((0x0000000000000001ULL << blockerIndex) & (opposingRooks | opposingQueens))
			!= 0x0000000000000000ULL)
		{
			result = true;
		}
	}

	blockerIndex = GetMSB(RayAttacksSW[squareIndex] & (position.WhitePieces | position.BlackPieces));

	if (blockerIndex != -1)
	{
		if (((0x0000000000000001ULL << blockerIndex) & (opposingBishops | opposingQueens))
			!= 0x0000000000000000ULL)
		{
			result = true;
		}
	}

	blockerIndex = GetMSB(RayAttacksW[squareIndex] & (position.WhitePieces | position.BlackPieces));

	if (blockerIndex != -1)
	{
		if (((0x0000000000000001ULL << blockerIndex) & (opposingRooks | opposingQueens))
			!= 0x0000000000000000ULL)
		{
			result = true;
		}
	}

	blockerIndex = GetLSB(RayAttacksNW[squareIndex] & (position.WhitePieces | position.BlackPieces));

	if (blockerIndex != -1)
	{
		if (((0x0000000000000001ULL << blockerIndex) & (opposingBishops | opposingQueens))
			!= 0x0000000000000000ULL)
		{
			result = true;
		}
	}

	if (position.ColorToMove == PieceColor::WHITE)
	{
		if (((((square & 0x00FEFEFEFEFEFEFEULL) << 7) & position.BlackPawns) != 0x0000000000000000ULL)
			|| ((((square & 0x007F7F7F7F7F7F7FULL) << 9) & position.BlackPawns) != 0x0000000000000000ULL))
		{
			result = true;
		}

		if ((KingAttacks[squareIndex] & position.BlackKing) != 0x0000000000000000ULL)
		{
			result = true;
		}
	}
	else
	{
		if (((((square & 0xFEFEFEFEFEFEFE00ULL) >> 9) & position.WhitePawns) != 0x0000000000000000ULL)
			|| ((((square & 0x7F7F7F7F7F7F7F00ULL) >> 7) & position.WhitePawns) != 0x0000000000000000ULL))
		{
			result = true;
		}

		if ((KingAttacks[squareIndex] & position.WhiteKing) != 0x0000000000000000ULL)
		{
			result = true;
		}
	}

	return result;
}

void MoveGenerator::AddMove(uint64_t src, uint64_t tgt, PieceRank rank, PieceColor color, int hm, int cs, uint64_t ep,
	PieceRank capture, PieceRank promotion, bool evade, Board& position)
{
	Move m;
	MoveUtil::InitializeMove(m, tgt, src, ep, color, rank, capture, promotion, hm, cs);

	if (evade)
	{
		Move nullMove;
		MoveUtil::InitializeMove(nullMove, 0x0000000000000000UL, 0x0000000000000000UL, 0x0000000000000000, PieceColor::NONE,
			PieceRank::NONE, PieceRank::NONE, PieceRank::NONE, 0, 0);

		Make(position, m);
		Make(position, nullMove);

		if (!IsSquareAttacked(color == PieceColor::WHITE ? position.WhiteKing : position.BlackKing, position))
		{
			moveList.push_back(m);
		}

		Unmake(position, nullMove);
		Unmake(position, m);
	}
	else
	{
		moveList.push_back(m);
	}
}
